# 配置指南

本文档详细介绍系统中所有配置文件的配置方法。

## 一、环境变量配置（.env 文件）

### 文件位置
- **路径**: 项目根目录下的 `.env` 文件
- **模板**: `.env.example`
- **创建方式**: `cp .env.example .env`

### 必需配置

#### 1. DATABASE_URL
PostgreSQL 数据库连接字符串。

**配置格式**:
```
postgresql://用户名:密码@主机:端口/数据库名
```

**详细说明**:
- **用户名**: PostgreSQL 用户（默认 `postgres`）
- **密码**: 数据库密码（如果包含特殊字符，需要 URL 编码）
- **主机**: 数据库主机地址
  - 本地: `localhost` 或 `127.0.0.1`
  - 远程: IP 地址或域名
- **端口**: PostgreSQL 端口（默认 `5432`）
- **数据库名**: 数据库名称（默认 `intent_system`）

**配置示例**:
```env
# 本地数据库
DATABASE_URL=postgresql://postgres:mypassword@localhost:5432/intent_system

# 远程数据库
DATABASE_URL=postgresql://user:pass@192.168.1.100:5432/intent_system

# 使用 SSL
DATABASE_URL=postgresql://user:pass@host:5432/db?sslmode=require

# 密码包含特殊字符（需要 URL 编码）
# 例如密码是 "p@ss#word"，编码后为 "p%40ss%23word"
DATABASE_URL=postgresql://postgres:p%40ss%23word@localhost:5432/intent_system
```

**验证配置**:
```bash
# 测试连接
psql $DATABASE_URL -c "SELECT 1;"
```

**配置影响**:
- 修改后需要重启服务
- 连接失败会导致服务无法启动

#### 2. OPENAI_API_KEY
OpenAI API 密钥，用于 LLM 和嵌入向量生成。

**获取方式**:
1. 访问 https://platform.openai.com/
2. 登录账户
3. 进入 "API Keys" 页面
4. 点击 "Create new secret key"
5. 复制生成的 API Key（只显示一次，请妥善保存）

**配置示例**:
```env
# OpenAI API Key（以 sk- 开头）
OPENAI_API_KEY=sk-proj-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# 如果使用 Azure OpenAI
# OPENAI_API_KEY=your-azure-key
# OPENAI_API_BASE=https://your-resource.openai.azure.com/
```

**验证配置**:
```bash
# 测试 API Key
curl https://api.openai.com/v1/models \
  -H "Authorization: Bearer $OPENAI_API_KEY"
```

**安全注意事项**:
- ⚠️ **不要提交到版本控制**（已在 `.gitignore` 中）
- ⚠️ 定期轮换 API Key
- ⚠️ 设置使用限额防止滥用
- ⚠️ 监控 API 使用量

**配置影响**:
- 无效的 API Key 会导致 LLM 调用失败
- 余额不足会导致服务无法生成回答

#### 3. LLM 多提供商配置（可选）

系统支持 **OpenAI、DeepSeek、Claude、Qianwen（通义千问）**，优先使用 `.env` 中已配置的密钥。

**选择当前使用的提供商**（四选一或由密钥自动推断）:
```env
# 可选：openai | deepseek | claude | qianwen
# 不设置时：按以下顺序自动选择「第一个已配置密钥」：OpenAI → DeepSeek → Claude → Qianwen
LLM_PROVIDER=openai
```

**各提供商 API Key（至少配置一个，优先使用 .env 中设置好的）**:
```env
# OpenAI（默认）
OPENAI_API_KEY=sk-your-openai-key
OPENAI_API_BASE=https://api.openai.com/v1

# DeepSeek
DEEPSEEK_API_KEY=sk-your-deepseek-key

# Claude（Anthropic）
ANTHROPIC_API_KEY=sk-ant-your-anthropic-key

# 通义千问 / Qianwen（阿里云 DashScope）
DASHSCOPE_API_KEY=sk-your-dashscope-key
DASHSCOPE_BASE_URL=https://dashscope.aliyuncs.com/compatible-mode/v1
```

**模型名（可选，不设则用默认）**:
```env
# 全局默认
LLM_MODEL=gpt-4-turbo-preview

# 按角色分别指定（可选）
LLM_ROUTER_MODEL=gpt-4-turbo-preview
LLM_DECIDER_MODEL=gpt-4-turbo-preview
LLM_ANSWERER_MODEL=gpt-4-turbo-preview
```

**嵌入模型（仅支持 OpenAI / Qianwen）**:
```env
EMBEDDING_PROVIDER=openai
EMBEDDING_MODEL=text-embedding-3-small
```

详细说明见 [LLM 多提供商配置](07_LLM多提供商配置.md)。

### 可选配置

#### 4. VECTOR_STORE_PATH
向量存储路径，用于存储文档嵌入向量。

**默认值**: `./data/chroma`

**配置示例**:
```env
# 相对路径（项目目录下）
VECTOR_STORE_PATH=./data/chroma

# 绝对路径
VECTOR_STORE_PATH=/var/lib/intent-system/chroma

# Windows 路径
VECTOR_STORE_PATH=C:\data\intent-system\chroma
```

**配置说明**:
- 目录不存在时会自动创建
- 需要确保目录有读写权限
- 生产环境建议使用持久化存储（如网络存储）

**配置影响**:
- 修改后需要重新索引所有文档
- 路径错误会导致向量检索失败

#### 4. DB_ECHO
是否输出 SQL 日志，用于调试。

**默认值**: `false`

**配置示例**:
```env
# 开发环境：启用 SQL 日志
DB_ECHO=true

# 生产环境：关闭 SQL 日志（提升性能）
DB_ECHO=false
```

**配置影响**:
- 启用后会输出所有 SQL 查询到控制台
- 生产环境建议关闭（影响性能）

#### 5. JAEGER_ENABLED
是否启用 Jaeger 分布式追踪。

**默认值**: `false`

**配置示例**:
```env
# 启用 Jaeger 追踪
JAEGER_ENABLED=true
JAEGER_HOST=localhost
JAEGER_PORT=6831

# 关闭追踪
JAEGER_ENABLED=false
```

**配置说明**:
- 需要先启动 Jaeger 服务
- 用于生产环境的性能监控和问题排查

**配置影响**:
- 启用后会发送追踪数据到 Jaeger
- 轻微影响性能（< 5%）

## 二、核心配置文件

### 1. config/constants.yaml

**文件位置**: `config/constants.yaml`  
**用途**: 定义系统的 8 个核心常量  
**修改频率**: 很少（系统级配置）

#### 1.1 Intent 枚举配置

**配置项**: `intents`

**说明**: 定义系统支持的所有意图类型

**配置示例**:
```yaml
intents:
  - KNOWLEDGE_QA          # 知识问答（偏 DOC）
  - LOOKUP_STATUS         # 查状态（偏 STRUCTURED/RESULT）
  - EXECUTE_TASK          # 需要执行动作流程（偏 WORKFLOW/TOOL）
  - DECISION_RECOMMEND    # 给方案建议（偏 DOC + 推理）
  - TROUBLESHOOT          # 排障（偏 DOC + WORKFLOW）
  - ACCOUNT_USER_SPECIFIC # 强用户态（必须 user_id）
  - OTHER                 # 其他
```

**添加新意图**:
```yaml
intents:
  - KNOWLEDGE_QA
  - LOOKUP_STATUS
  - YOUR_NEW_INTENT      # 添加新意图
```

**配置影响**:
- 需要同步修改代码中的 Intent 枚举
- Router 会识别新意图类型

#### 1.2 数据源定义

**配置项**: `data_sources`

**说明**: 定义各种数据源的存储方式和索引类型

**配置示例**:
```yaml
data_sources:
  DOC:
    - name: "knowledge_base"
      description: "预制知识库（Markdown/HTML/JSON）"
      storage: "s3"                    # 存储方式：s3, local, postgres
      indexing: ["vector", "keyword"]  # 索引类型：vector, keyword, structured
  
  WORKFLOW:
    - name: "workflow_registry"
      description: "工作流注册表"
      storage: "postgres"
      indexing: ["keyword", "metadata"]
  
  RESULT:
    - name: "execution_cache"
      description: "历史执行结果缓存"
      storage: "postgres"
      indexing: ["keyword", "structured"]
      freshness_required: true        # 是否要求新鲜度
```

**添加新数据源**:
```yaml
data_sources:
  DOC:
    - name: "custom_kb"
      description: "自定义知识库"
      storage: "local"
      indexing: ["vector", "keyword"]
```

**配置影响**:
- 影响检索器的行为
- 新增数据源需要实现对应的检索器

#### 1.3 输出格式配置

**配置项**: `output_format`

**说明**: 定义系统支持的输出格式和选择规则

**配置示例**:
```yaml
output_format:
  default: "steps"  # 默认输出格式
  
  options:
    - text: "纯文本（自然语言）"
      use_case: "一般问答"
      citation_style: "inline"
    
    - steps: "步骤化（结构化说明）"
      use_case: "默认（推荐）"
      citation_style: "inline"
      structure:
        - summary: "一句话总结"
        - steps: ["步骤1", "步骤2", ...]
        - evidence: ["引用1", "引用2", ...]
    
    - json: "JSON（结构化数据）"
      use_case: "需要结果数据时选择"
      citation_style: "metadata"
    
    - table: "表格（结构化展示）"
      use_case: "列表、对比类查询"
      citation_style: "inline"
  
  selection_rules:
    - if: "user.options.output_format specified"
      then: "use user specified"
    - elif: "intent == LOOKUP_STATUS"
      then: "prefer json or table"
    - elif: "intent == EXECUTE_TASK"
      then: "prefer steps"
    - else: "use default (steps)"
```

**修改默认格式**:
```yaml
output_format:
  default: "json"  # 改为 JSON 格式
```

**配置影响**:
- 影响 Answerer 的输出格式
- 用户可以通过 API 参数覆盖

#### 1.4 多租户隔离配置

**配置项**: `multi_tenant`

**说明**: 配置多租户隔离规则

**配置示例**:
```yaml
multi_tenant:
  enabled: true
  isolation_level: "tenant_id"
  
  fields:
    tenant_id: "required"   # 必须字段
    user_id: "optional"     # 可选字段
    team_id: "optional"
  
  isolation_rules:
    RESULT:
      - filter_by: ["tenant_id", "user_id"]
      - enforce: "strict"   # 严格隔离
    WORKFLOW:
      - filter_by: ["tenant_id"]
      - enforce: "strict"
    DOC:
      - filter_by: ["tenant_id"]
      - enforce: "soft"     # 软隔离（可共享）
  
  default_tenant: null      # 不允许默认租户
```

**禁用多租户**:
```yaml
multi_tenant:
  enabled: false
```

**配置影响**:
- 影响数据访问权限
- 严格隔离确保数据安全

### 2. config/ranking.yaml

**文件位置**: `config/ranking.yaml`  
**用途**: 检索打分权重配置  
**修改频率**: 根据效果调整

#### 2.1 全局权重配置

**配置项**: `weights`

**说明**: 定义各种分数的权重

**配置示例**:
```yaml
weights:
  semantic: 0.5      # 语义相似度权重（0.0-1.0）
  keyword: 0.3       # 关键词匹配权重
  freshness: 0.15    # 新鲜度权重
  policy: 0.05       # 策略权重（权限、成本等）
```

**权重调整建议**:
- **提高 semantic**: 更关注语义理解，适合复杂查询
  ```yaml
  weights:
    semantic: 0.7
    keyword: 0.2
    freshness: 0.1
  ```
- **提高 keyword**: 更关注精确匹配，适合关键词明确的查询
  ```yaml
  weights:
    semantic: 0.3
    keyword: 0.5
    freshness: 0.2
  ```
- **提高 freshness**: 更关注数据新鲜度，适合实时性要求高的场景
  ```yaml
  weights:
    semantic: 0.4
    keyword: 0.3
    freshness: 0.3
  ```

**配置影响**:
- 直接影响检索结果的排序
- 需要根据实际效果调整

#### 2.2 Freshness 阈值配置

**配置项**: `freshness`

**说明**: 定义新鲜度检查的阈值

**配置示例**:
```yaml
freshness:
  required_threshold: 0.7    # 必须满足的新鲜度阈值（0.0-1.0）
  penalty_threshold: 0.5    # 开始惩罚的阈值
  expired_penalty: -1.0      # 过期直接剔除（设为0则不剔除）
```

**调整示例**:
```yaml
# 更严格的新鲜度要求
freshness:
  required_threshold: 0.9    # 提高阈值
  penalty_threshold: 0.7
  expired_penalty: -1.0

# 宽松的新鲜度要求
freshness:
  required_threshold: 0.5    # 降低阈值
  penalty_threshold: 0.3
  expired_penalty: -0.5      # 过期不直接剔除，只是降分
```

#### 2.3 各 Target 特定配置

**配置项**: `target_configs`

**说明**: 为不同类型的资源配置不同的权重

**配置示例**:
```yaml
target_configs:
  DOC:
    semantic_weight: 0.6
    keyword_weight: 0.4
    freshness_weight: 0.0    # DOC 不考虑新鲜度
  
  WORKFLOW:
    semantic_weight: 0.4
    keyword_weight: 0.3
    metadata_weight: 0.3     # 元数据匹配（capabilities, tags）
  
  RESULT:
    semantic_weight: 0.3
    keyword_weight: 0.2
    freshness_weight: 0.4    # RESULT 更关注新鲜度
    subject_match_weight: 0.1  # subject_keys 匹配
  
  STRUCTURED:
    semantic_weight: 0.2
    keyword_weight: 0.5      # 结构化数据更关注关键词
    structured_match_weight: 0.3
```

**配置影响**:
- 不同类型的资源使用不同的打分策略
- 可以针对业务场景优化

### 3. config/policy.yaml

**文件位置**: `config/policy.yaml`  
**用途**: 策略配置（权限、成本、风险控制）  
**修改频率**: 根据业务需求调整

#### 3.1 权限配置

**配置项**: `permissions`

**说明**: 定义每个租户允许使用的工作流和工具

**配置示例**:
```yaml
permissions:
  # 默认租户（所有用户）
  default_tenant:
    allowed_workflows: ["*"]      # 允许所有工作流
    allowed_tools: ["*"]          # 允许所有工具
    blocked_workflows: []         # 阻止的工作流
    blocked_tools: []             # 阻止的工具
  
  # 特定租户
  tenant_a:
    allowed_workflows: 
      - "wf_order_status"
      - "wf_user_info"
      - "wf_*"                    # 支持通配符
    allowed_tools:
      - "tool_sql_query"
      - "tool_api_call"
    blocked_workflows:
      - "wf_admin_*"              # 阻止所有 admin 工作流
    blocked_tools:
      - "tool_delete"              # 阻止删除工具
  
  # 受限租户
  tenant_restricted:
    allowed_workflows: 
      - "wf_readonly_*"           # 只允许只读工作流
    allowed_tools: []             # 不允许任何工具
    blocked_workflows: ["*"]       # 阻止所有（除了 allowed 中的）
```

**配置规则**:
- `allowed_*`: 白名单（优先级高）
- `blocked_*`: 黑名单
- 支持通配符 `*`
- 如果 `allowed` 为空，则不允许任何操作

**配置影响**:
- 直接影响用户能执行的操作
- 生产环境必须配置

#### 3.2 成本限制配置

**配置项**: `cost_limits`

**说明**: 定义每轮请求的成本上限

**配置示例**:
```yaml
cost_limits:
  default:
    max_tokens: 10000        # 最大 token 数
    max_latency_ms: 5000     # 最大延迟（毫秒）
    max_usd: 0.01           # 最大成本（美元）
  
  # 按租户覆盖
  tenant_overrides:
    tenant_premium:
      max_tokens: 50000
      max_latency_ms: 10000
      max_usd: 0.1
    tenant_basic:
      max_tokens: 5000
      max_latency_ms: 3000
      max_usd: 0.005
```

**成本计算**:
- Token 成本: 根据使用的模型计算
- 延迟成本: 影响用户体验
- USD 成本: 直接 API 调用成本

**配置影响**:
- 超过限制的请求会被拒绝
- 防止成本失控

#### 3.3 风险限制配置

**配置项**: `risk_limits`

**说明**: 定义风险等级限制

**配置示例**:
```yaml
risk_limits:
  default:
    max_risk_level: "mid"         # 允许的最大风险等级：low, mid, high
    block_high_risk: true         # 是否阻止高风险操作
  
  tenant_overrides:
    tenant_trusted:
      max_risk_level: "high"      # 信任租户允许高风险
      block_high_risk: false
    tenant_untrusted:
      max_risk_level: "low"       # 不信任租户只允许低风险
      block_high_risk: true
```

**风险等级定义**:
- **low**: 只读操作、查询操作
- **mid**: 数据修改、状态更新
- **high**: 删除操作、敏感操作

**配置影响**:
- 高风险操作需要特殊权限
- 保护系统安全

#### 3.4 执行策略配置

**配置项**: `execution`

**说明**: 定义工作流执行的策略

**配置示例**:
```yaml
execution:
  max_retries: 3                   # 最大重试次数
  timeout_seconds: 30              # 超时时间（秒）
  idempotency_window_seconds: 300  # 幂等性窗口（5分钟）
```

**调整示例**:
```yaml
# 更严格的执行策略
execution:
  max_retries: 1                   # 减少重试
  timeout_seconds: 10              # 缩短超时
  idempotency_window_seconds: 60   # 缩短幂等窗口

# 更宽松的执行策略
execution:
  max_retries: 5
  timeout_seconds: 60
  idempotency_window_seconds: 600
```

## 三、数据库配置

### 1. migrations/alembic.ini

**文件位置**: `migrations/alembic.ini`  
**用途**: Alembic 数据库迁移工具配置  
**修改频率**: 很少

#### 关键配置项

**script_location**:
```ini
[alembic]
script_location = migrations
```
- 迁移脚本目录
- 一般不需要修改

**sqlalchemy.url**:
```ini
sqlalchemy.url = driver://user:pass@localhost/dbname
```
- ⚠️ **不建议在此配置**，应使用环境变量 `DATABASE_URL`
- 如果配置，会被 `migrations/env.py` 中的环境变量覆盖

**file_template**:
```ini
# 默认格式
file_template = %%(rev)s_%%(slug)s

# 带日期的格式（可选）
file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s
```

**配置示例**:
```ini
[alembic]
script_location = migrations
prepend_sys_path = .
version_path_separator = os

# 日志配置
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console

[logger_sqlalchemy]
level = WARN

[logger_alembic]
level = INFO
```

### 2. services/resource_registry/database.py

**文件位置**: `services/resource_registry/database.py`  
**用途**: 数据库连接和会话管理  
**修改频率**: 根据性能需求调整

#### 连接池配置

**当前配置**:
```python
engine = create_engine(
    DATABASE_URL,
    poolclass=NullPool,      # 无连接池（开发环境）
    echo=os.getenv("DB_ECHO", "false").lower() == "true",
    pool_pre_ping=True,      # 连接前检查
)
```

**生产环境推荐配置**:
```python
engine = create_engine(
    DATABASE_URL,
    pool_size=20,            # 连接池大小（建议：CPU核心数 * 2）
    max_overflow=40,         # 最大溢出连接
    pool_pre_ping=True,      # 连接前检查（推荐开启）
    pool_recycle=3600,       # 连接回收时间（秒，建议1小时）
    echo=False,              # 生产环境关闭 SQL 日志
    connect_args={
        "connect_timeout": 10,  # 连接超时（秒）
        "application_name": "intent_system"  # 应用名称
    }
)
```

**配置说明**:
- **pool_size**: 连接池大小，根据并发量调整
- **max_overflow**: 超出 pool_size 后允许的额外连接
- **pool_recycle**: 连接使用时间超过此值后回收，防止连接过期
- **pool_pre_ping**: 使用前检查连接是否有效

**性能调优**:
```python
# 高并发场景
pool_size=50
max_overflow=100

# 低并发场景
pool_size=5
max_overflow=10
```

## 四、Prompt 模板配置

### 文件位置
- `prompts/router_v1.md` - Router Prompt
- `prompts/decider_v1.md` - Decider Prompt
- `prompts/answerer_v1.md` - Answerer Prompt

### 修改方式

**直接编辑 Markdown 文件**:
```markdown
# Intent Router Prompt v1

你是一个意图路由系统...

## 任务
分析用户消息，识别意图...

## 输出格式（严格 JSON）
...
```

**注意事项**:
- 修改后需要重启服务
- 建议先备份原文件
- 可以创建新版本（如 `router_v2.md`）

### 版本管理

**创建新版本**:
```bash
cp prompts/router_v1.md prompts/router_v2.md
# 编辑 router_v2.md
```

**在代码中使用新版本**:
```python
# services/orchestrator/router.py
prompt_path = Path(__file__).parent.parent.parent / "prompts" / "router_v2.md"
```

## 五、LLM 模型配置（多提供商）

系统支持 **OpenAI、DeepSeek、Claude、Qianwen**，**优先使用 .env 中配置的密钥**；模型与提供商均建议通过环境变量配置，无需改代码。

### 1. 提供商与模型（.env）

- **LLM_PROVIDER**: `openai` | `deepseek` | `claude` | `qianwen`（不设则按已配置 Key 自动推断）
- **LLM_MODEL**: 全局默认模型
- **LLM_ROUTER_MODEL** / **LLM_DECIDER_MODEL** / **LLM_ANSWERER_MODEL**: 按角色指定模型（可选）

各提供商默认模型与可选模型见 [LLM 多提供商配置](07_LLM多提供商配置.md)。

### 2. Router / Decider / Answerer

**文件位置**: `services/orchestrator/router.py`、`decider.py`、`answerer.py`

三者均通过统一 LLM 客户端获取 `client`，不传参时从 **config/llm_config.py** 读取 .env 中的提供商与密钥。如需在代码中覆盖，可传入 `provider`、`api_key`、`base_url`、`model`。

### 3. 嵌入模型配置（OpenAI / Qianwen）

**文件位置**: `services/retrieval/embedding.py`

**配置方式（.env 优先）**:
- **EMBEDDING_PROVIDER**: `openai` | `qianwen`（不设则：有 DASHSCOPE_API_KEY 用 qianwen，否则 openai）
- **EMBEDDING_MODEL**: 如 `text-embedding-3-small`（OpenAI）、`text-embedding-v3`（Qianwen）

**可选模型**:
- OpenAI: `text-embedding-3-small`（1536 维）、`text-embedding-3-large`（3072 维）
- Qianwen: `text-embedding-v3`（1536 维）

详细说明见 [LLM 多提供商配置](07_LLM多提供商配置.md)。

## 六、服务端口配置

### 文件位置
- `run.py` - 启动脚本
- `services/chat_api/main.py` - 主服务

### 配置方法

**方式一：修改 run.py**
```python
if __name__ == "__main__":
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,  # 修改这里
        reload=True
    )
```

**方式二：使用环境变量**
```python
import os
port = int(os.getenv("PORT", 8000))
host = os.getenv("HOST", "0.0.0.0")
```

**方式三：命令行参数**
```bash
uvicorn services.chat_api.main:app --port 8001 --host 0.0.0.0
```

## 七、配置生效方式

### 需要重启的配置
- 环境变量（`.env`）
- YAML 配置文件（`config/*.yaml`）
- Python 代码中的配置
- Prompt 模板

### 热更新的配置
- 部分配置可以通过 API 动态更新（需要实现）

### 配置验证

**验证环境变量**:
```bash
# 检查 .env 文件
cat .env

# 检查环境变量是否加载
python -c "import os; from dotenv import load_dotenv; load_dotenv(); print(os.getenv('DATABASE_URL'))"
```

**验证 YAML 配置**:
```python
# 检查配置是否有效
from config.constants import load_constants
constants = load_constants()
print(constants)
```

## 八、配置检查清单

### 安装前检查
- [ ] `.env` 文件已创建并配置
- [ ] `DATABASE_URL` 格式正确
- [ ] `OPENAI_API_KEY` 有效
- [ ] 数据库已创建

### 启动前检查
- [ ] 所有必需配置项已设置
- [ ] 配置文件格式正确（YAML 语法）
- [ ] 端口未被占用
- [ ] 数据库连接正常

### 生产环境检查
- [ ] 安全配置已设置（CORS、认证）
- [ ] 日志配置正确
- [ ] 性能参数已优化
- [ ] 备份策略已配置

## 九、常见配置场景

### 场景 1: 开发环境
```yaml
# .env
DB_ECHO=true
JAEGER_ENABLED=false

# config/ranking.yaml
weights:
  semantic: 0.5
  keyword: 0.3
```

### 场景 2: 生产环境
```yaml
# .env
DB_ECHO=false
JAEGER_ENABLED=true

# config/policy.yaml
permissions:
  default_tenant:
    allowed_workflows: ["wf_safe_*"]  # 限制工作流
```

### 场景 3: 高并发场景
```python
# database.py
pool_size=50
max_overflow=100
```

### 场景 4: 成本优化
```python
# router.py, decider.py, answerer.py
model = "gpt-3.5-turbo"  # 使用低成本模型
```

## 十、配置故障排查

### 问题 1: 配置不生效
**检查**:
1. 配置文件路径是否正确
2. 配置文件格式是否正确（YAML 语法）
3. 是否重启了服务
4. 环境变量是否正确加载

### 问题 2: 配置格式错误
**检查**:
```bash
# 验证 YAML 格式
python -c "import yaml; yaml.safe_load(open('config/constants.yaml'))"
```

### 问题 3: 配置冲突
**检查**:
- 多个配置文件是否有冲突
- 环境变量是否覆盖了配置文件
- 代码默认值是否覆盖了配置

## 十一、配置备份

### 备份配置文件
```bash
# 备份所有配置
tar -czf config_backup_$(date +%Y%m%d).tar.gz \
  config/ \
  .env \
  migrations/alembic.ini \
  prompts/
```

### 恢复配置
```bash
# 恢复配置
tar -xzf config_backup_20260123.tar.gz
```

## 十二、配置最佳实践

1. **版本控制**: 将配置文件（除 `.env`）纳入版本控制
2. **环境分离**: 不同环境使用不同的配置文件
3. **配置验证**: 启动前验证配置有效性
4. **文档记录**: 修改配置后更新文档
5. **备份策略**: 定期备份配置文件
6. **安全第一**: 敏感信息使用环境变量
7. **性能监控**: 配置变更后监控性能影响
